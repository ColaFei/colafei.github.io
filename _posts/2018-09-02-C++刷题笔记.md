---
layout:     post
title:      C++刷题笔记
subtitle:   难点
date:       2018-10-09
author:     ColaFei
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - C++
---

>最后更新于10月10日

### ```  操作符  ```

``` sizeof() ```是C/C++中的一个操作符，作用就是返回一个对象或者类型所占的内存字节数

```c#
int i;
sizeof(int);    //值为4
sizeof(i);      //值为4，等价于sizeof(int)
sizeof i;       //值为4
sizeof(2);      //值为4，等价于sizeof(int),因为2的类型为int
sizeof(2+3.14); //值为8，等价于sizeof(double),因为此表达式的结果的类型为double

char ary[sizeof(int)*10];  
```

``` & ```位与运算，二进制中最后一位为0为偶数，为1是奇数，所以这个可以用来判断数的奇偶性
```c#
int y;
if(y&1)  //位与运算，1就是0000000001，如果y的最后一位为xxxxxxx0，则结果为false；最后一位为xxxxxxx1，结果为true
```

``` >> ```右移运算符，相当于除以2；
``` << ```左移运算符，相当于乘以2，后边补0

```c#
int y=5;
y=y>>1;   //y的二进制为0101，y>>1表示y右移1位，即把最右边一位的1删掉，变为010，此时y=2
y=y>>2;   //右移两位，把最右边两位的01去掉，变为01.此时y=1
```

### ```  #include<vector>  ```
相当于一个动态的数组，可以不用指定大小

```c#
vector<int> s;                //定义一个整数型向量s，大小没有指定
vector<int> s={1,2,3,4,5};    //定义一个整数型向量s
s.push_back(1);               //向s的最后添加一个数字1
s.pop_back();                 //去掉向量的最后一个元素
```

### ```  #include<algorithm>  ```

``` reverse ```函数用于反转容器或字符串（.begin(),.end()）内的顺序

```c#
vector<int> s={2,3,8,9,4};       //定义容器
reverse(s.begin(),s.end());      //s的值变为4,9,8,3,2

string str="likeyou";            //定义字符串
reverse(str.begin(),str.end());  //str的结果变为"uoyekil";
```

``` sort ```函数用于对数组中的元素进行排序

``` 用法 ```

1. sort函数可以三个参数也可以两个参数

2. 它使用的排序方法是类似于快排的方法，时间复杂度是n*log2(n)

3. Sort函数有三个参数（第三个参数可不写）：

	（1）第一个是要排序的数组的起始地址；
	
	（2）第二个是结束的地址（最后一位要排序的地址）；
	
	（3）第三个参数是排序的方法，可以是从小到大也可以是从大到小，还可以不写第三个参数，此时默认是从小到大排序。
	
```c#
int a[20] = {2,4,1,5,3,58,41,6,9,15,36};
sort(a,a+20);     //a[20] = {1,2,3,4,5,6,9,15,36,41,58}
```
	
	

``` nth_element(first, nth, last, compare) ```
求[first,last]区间中第n大小的元素，加入compare函数，就按compare函数的方式比较。

通过调用```nth_element(start, start+n, end)```方法可以使第n大元素处于第n位置（从0开始,其位置是下标为 
n的元素），并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的

```c#	
//求数组中第k个最大元素
class Solution {
public:
	int findKthLargest(vector<int>& nums, int k) {
		nth_element(nums.begin(),nums.end()-k,nums.end());
		return *(nums.end()-k);
    }
};
```
	
### ```  #include<string>  ```

``` stoi ```函数用于将字符串转换成int类型，``` stol ```函数用于将字符串转换成long类型，
``` stoll ```函数用于将字符串转换成long long类型

```c#	
string a="172673";       //定义数字型字符串
int b=stoi(a);           //b=172673
```

``` insert ```函数用于在一个字符串中插入另一个字符串

```c#
string str1="Iyou";
string str2="like";
str1.insert(pos,str2); //在str1的pos位置插入字符串str2，后面的字符一次向后退
str1.insert(1,str2);   //str1的值变为"Ilikeyou"
```

``` substr ```函数用于复制截取子字符串
```c#
string x="Hello_World";
cout<<x.substr(5)<<endl;   //截取x[5]到结尾
cout<<x.substr(0,5)<<endl; //从x[0]为始，向后截取5位（包含x[0]）
```


### ```  #include<queue>  ```

队列：先进先出的一个容器

``` 定义queue对象： ```

```c#
queue<int> q1;
queue<double> q2;
queue<ListNode*> q3;
```

``` 基本操作： ```
```c#
q.push(x);   //1.入队，将x元素接到队列的末端；
q.pop();     //2.出队，弹出队列的第一个元素，并不会返回元素的值；
q.front();   //3.访问队首元素；
q.back();    //4.访问队尾元素；
q.size();    //5.访问队中的元素个数。
```

### ```  #include<stack>  ```

栈：后进先出的一个容器

``` 定义stack对象： ```

```c#
stack<int> stk;
```

``` 基本操作： ```
```c#
stk.empty();   //判断栈是否为空
stk.size();    //返回栈中元素的个数
stk.pop();     //删除栈顶元素但不返回其值
stk.top();     //返回栈顶的元素，但不删除该元素
stk.push();    //在栈顶压入新元素
```


### ```  反转链表  ```

``` 非递归 （方法一）```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *pre=new ListNode(0);
	ListNode *p1=pre->next,*temp;
	while(p1->next){
		temp=p1->next;
		p1->next=temp->next;
		temp->next=pre->next;
		pre->next=temp;
	}
	return pre->next;
}
```

``` 非递归 （方法二）```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *pre=NULL,*next=NULL;
	while(head){
		next=head->next;
		head->next=pre;
		pre=head;
		head=next;
	}
	return pre;
}
```

``` 递归（方法一） ```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)                      //链表为空直接返回，而head->next为空是递归基
		return head;
	ListNode *newhead=ReverseList(head->next);  //一直循环到链尾
	head->next->next=head;                      //翻转链表的指向
	head->next=NULL;                            //记得赋值NULL，防止链表错乱
	return newhead;                             //新链表头永远指向的是原链表的链尾
}
```

``` 递归（方法二） ```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *secendElem=head->next;
	head->next=NULL;
	ListNode *reverseRest=ReverseList(secondElem);
	secondElem->next=head;
	return reverseRest;
}
```

