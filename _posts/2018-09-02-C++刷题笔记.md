---
layout:     post
title:      C++刷题笔记
subtitle:   难点
date:       2018-10-09
author:     ColaFei
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - C++
---

>最后更新于10月9日

### ```  #include<vector>  ```
相当于一个动态的数组，可以不用指定大小

```c#
vector<int> s;                //定义一个整数型向量s，大小没有指定
vector<int> s={1,2,3,4,5};    //定义一个整数型向量s
s.push_back(1);               //向s的最后添加一个数字1
s.pop_back();                 //去掉向量的最后一个元素
```

### ```  #include<algorithm>  ```

``` reverse ```函数用于反转容器或字符串（.begin(),.end()）内的顺序

```c#
vector<int> s={2,3,8,9,4};       //定义容器
reverse(s.begin(),s.end());      //s的值变为4,9,8,3,2

string str="likeyou";            //定义字符串
reverse(str.begin(),str.end());  //str的结果变为"uoyekil";
```

``` nth_element(first, nth, last, compare) ```
求[first,last]区间中第n大小的元素，加入compare函数，就按compare函数的方式比较。
通过调用nth_element(start, start+n, end)方法可以使第n大元素处于第n位置（从0开始,其位置是下标为 
n的元素），并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的
```c#	
//求数组中第k个最大元素
class Solution {
public:
	int findKthLargest(vector<int>& nums, int k) {
		nth_element(nums.begin(),nums.end()-k,nums.end());
		return *(nums.end()-k);
    }
};
```
	
### ```  #include<string>  ```

``` stoi ```函数用于将字符串转换成int类型

```c#	
string a="172673";       //定义数字型字符串
int b=stoi(a);           //b=172673
```

``` insert ```函数用于在一个字符串中插入另一个字符串

```c#
string str1="Iyou";
string str2="like";
str1.insert(pos,str2); //在str1的pos位置插入字符串str2，后面的字符一次向后退
str1.insert(1,str2);   //str1的值变为"Ilikeyou"
```

### ```  反转链表  ```

``` 非递归 （方法一）```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *pre=new ListNode(0);
	ListNode *p1=pre->next,temp;
	while(p1->next){
		temp=p1->next;
		p1->next=temp->next;
		temp->next=pre->next;
		pre->next=temp;
	}
	return pre->next;
}
```

``` 非递归 （方法二）```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *pre=NULL,*next=NULL;
	while(head){
		next=head->next;
		head->next=pre;
		pre=head;
		head=next;
	}
	return pre;
}
```

``` 递归（方法一） ```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)                      //链表为空直接返回，而head->next为空是递归基
		return head;
	ListNode *newhead=ReverseList(head->next);  //一直循环到链尾
	head->next->next=head;                      //翻转链表的指向
	head->next=NULL;                            //记得赋值NULL，防止链表错乱
	return newhead;                             //新链表头永远指向的是原链表的链尾
}
```

``` 递归（方法二） ```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *secendElem=head->next;
	head->next=NULL;
	ListNode *reverseRest=ReverseList(secondElem);
	secondElem->next=head;
	return reverseRest;
}
```

