---
layout:     post
title:      C++刷题笔记
subtitle:   难点
date:       2018-10-09
author:     ColaFei
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - C++
---

>最后更新于10月10日

### ```  操作符  ```

``` sizeof() ```是C/C++中的一个操作符，作用就是返回一个对象或者类型所占的内存字节数

```c#
int i;
sizeof(int);    //值为4
sizeof(i);      //值为4，等价于sizeof(int)
sizeof i;       //值为4
sizeof(2);      //值为4，等价于sizeof(int),因为2的类型为int
sizeof(2+3.14); //值为8，等价于sizeof(double),因为此表达式的结果的类型为double

char ary[sizeof(int)*10];  
```

``` & ```位与运算，二进制中最后一位为0为偶数，为1是奇数，所以这个可以用来判断数的奇偶性
```c#
int y;
if(y&1)  //位与运算，1就是0000000001，如果y的最后一位为xxxxxxx0，则结果为false；最后一位为xxxxxxx1，结果为true
```


### ```  #include<vector>  ```
相当于一个动态的数组，可以不用指定大小

```c#
vector<int> s;                //定义一个整数型向量s，大小没有指定
vector<int> s={1,2,3,4,5};    //定义一个整数型向量s
s.push_back(1);               //向s的最后添加一个数字1
s.pop_back();                 //去掉向量的最后一个元素
```

### ```  #include<algorithm>  ```

``` reverse ```函数用于反转容器或字符串（.begin(),.end()）内的顺序

```c#
vector<int> s={2,3,8,9,4};       //定义容器
reverse(s.begin(),s.end());      //s的值变为4,9,8,3,2

string str="likeyou";            //定义字符串
reverse(str.begin(),str.end());  //str的结果变为"uoyekil";
```

``` nth_element(first, nth, last, compare) ```
求[first,last]区间中第n大小的元素，加入compare函数，就按compare函数的方式比较。

通过调用```nth_element(start, start+n, end)```方法可以使第n大元素处于第n位置（从0开始,其位置是下标为 
n的元素），并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的

```c#	
//求数组中第k个最大元素
class Solution {
public:
	int findKthLargest(vector<int>& nums, int k) {
		nth_element(nums.begin(),nums.end()-k,nums.end());
		return *(nums.end()-k);
    }
};
```
	
### ```  #include<string>  ```

``` stoi ```函数用于将字符串转换成int类型

```c#	
string a="172673";       //定义数字型字符串
int b=stoi(a);           //b=172673
```

``` insert ```函数用于在一个字符串中插入另一个字符串

```c#
string str1="Iyou";
string str2="like";
str1.insert(pos,str2); //在str1的pos位置插入字符串str2，后面的字符一次向后退
str1.insert(1,str2);   //str1的值变为"Ilikeyou"
```

### ```  #include<queue>  ```

先进先出的一个容器

``` 定义queue对象： ```

```c#
queue<int> q1;
queue<double> q2;
queue<ListNode*> q3;
```

``` 基本操作： ```
```c#
q.push(x);   //1.入队，将x元素接到队列的末端；
q.pop();     //2.出队，弹出队列的第一个元素，并不会返回元素的值；
q.front();   //3.访问队首元素；
q.back();    //4.访问队尾元素；
q.size();    //5.访问队中的元素个数。
```

### ```  反转链表  ```

``` 非递归 （方法一）```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *pre=new ListNode(0);
	ListNode *p1=pre->next,temp;
	while(p1->next){
		temp=p1->next;
		p1->next=temp->next;
		temp->next=pre->next;
		pre->next=temp;
	}
	return pre->next;
}
```

``` 非递归 （方法二）```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *pre=NULL,*next=NULL;
	while(head){
		next=head->next;
		head->next=pre;
		pre=head;
		head=next;
	}
	return pre;
}
```

``` 递归（方法一） ```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)                      //链表为空直接返回，而head->next为空是递归基
		return head;
	ListNode *newhead=ReverseList(head->next);  //一直循环到链尾
	head->next->next=head;                      //翻转链表的指向
	head->next=NULL;                            //记得赋值NULL，防止链表错乱
	return newhead;                             //新链表头永远指向的是原链表的链尾
}
```

``` 递归（方法二） ```
```c#
ListNode* ReverseList(ListNode* head){
	if(!head||!head->next)
		return head;
	ListNode *secendElem=head->next;
	head->next=NULL;
	ListNode *reverseRest=ReverseList(secondElem);
	secondElem->next=head;
	return reverseRest;
}
```

